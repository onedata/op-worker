%%%-------------------------------------------------------------------
%%% @author Lukasz Opiola
%%% @copyright (C) 2021 ACK CYFRONET AGH
%%% This software is released under the MIT license
%%% cited in 'LICENSE.txt'.
%%% @end
%%%-------------------------------------------------------------------
%%% @doc
%%% Model storing an activity log for an OpenFaaS function - status reports
%%% (i.e. kubernetes events) collected for all pods that execute given function.
%%% The reports are kept in a form of an infinite log, one per each pod.
%%%
%%% NOTE: original timestamps of pod events are saved into a pod event log
%%% alongside the event payload. They are returned during listing instead of
%%% the internal timestamps generated by infinite log during appending.
%%% Thanks to this approach, the listing shows real timestamps of the events,
%%% but as a downside it is possible that the listed logs will not be strictly
%%% sorted (they may be some deviations if the logs were not submitted in order).
%%% @end
%%%-------------------------------------------------------------------
-module(atm_openfaas_function_activity_registry).
-author("Lukasz Opiola").

-include("modules/automation/atm_execution.hrl").
-include("modules/datastore/datastore_models.hrl").
-include("modules/datastore/datastore_runner.hrl").

%% API
-export([ensure_for_function/1]).
-export([delete/1]).
-export([get/1]).
-export([consume_report/1]).
-export([list_pod_events/2]).

%% datastore_model callbacks
-export([get_ctx/0, get_record_version/0, get_record_struct/1]).

-type id() :: binary().
-type diff() :: datastore_doc:diff(record()).
-type record() :: #atm_openfaas_function_activity_registry{}.
-type doc() :: datastore_doc:doc(record()).

% identifier of a pod that executes an OpenFaaS function - each function can have
% multiple pods, which may be started or terminated at different moments.
-type pod_id() :: binary().

% status of a pod, as reported by Kubernetes (e.g. <<"Scheduled">> or <<"Created">>)
-type pod_status() :: binary().

% a single entry in a pod's infinite log of events (status reports)
-type pod_event() :: json_utils:json_map().

-export_type([id/0, diff/0, record/0, doc/0]).
-export_type([pod_id/0, pod_status/0, pod_event/0]).

-type function_name() :: atm_openfaas_task_executor:function_name().

-define(CTX, #{model => ?MODULE}).

%%%===================================================================
%%% API functions
%%%===================================================================

-spec ensure_for_function(function_name()) -> {ok, id()} | {error, term()}.
ensure_for_function(FunctionName) ->
    RegistryId = gen_registry_id(FunctionName),
    Doc = #document{
        key = RegistryId,
        value = #atm_openfaas_function_activity_registry{}
    },
    case datastore_model:create(?CTX, Doc) of
        {ok, _} ->
            {ok, RegistryId};
        {error, already_exists} ->
            {ok, RegistryId};
        {error, _} = Error ->
            Error
    end.


-spec delete(id()) -> ok | {error, term()}.
delete(RegistryId) ->
    {ok, #document{value = #atm_openfaas_function_activity_registry{
        pod_event_logs = PodEventLogs
    }}} = datastore_model:get(?CTX, RegistryId),
    maps:foreach(fun(_PodId, LogId) ->
        json_based_infinite_log_backend:destroy(LogId)
    end, PodEventLogs),
    datastore_model:delete(?CTX, RegistryId).


-spec get(id()) -> {ok, record()} | {error, term()}.
get(RegistryId) ->
    case datastore_model:get(?CTX, RegistryId) of
        {ok, #document{value = Registry}} ->
            {ok, Registry};
        {error, _} = Error ->
            Error
    end.


-spec consume_report(atm_openfaas_function_activity_report:record()) -> ok.
consume_report(#atm_openfaas_function_activity_report{
    type = atm_openfaas_function_pod_status_report,
    batch = Batch
}) ->
    lists:foreach(fun consume_pod_status_report/1, Batch).


-spec list_pod_events(infinite_log:log_id(), infinite_log_browser:listing_opts()) ->
    {ok, {done | more, [{infinite_log:entry_index(), infinite_log:timestamp(), pod_event()}]}} | {error, term()}.
list_pod_events(LogId, ListingOpts) ->
    case json_based_infinite_log_backend:list(LogId, ListingOpts) of
        {error, _} = Error ->
            Error;
        {ok, {Marker, EntrySeries}} ->
            {ok, {Marker, lists:map(fun({EntryIndex, _InfiniteLogTimestamp, DecodedLogValue}) ->
                {EventTimestamp, EventPayload} = unpack_pod_event(DecodedLogValue),
                {EntryIndex, EventTimestamp, EventPayload}
            end, EntrySeries)}}
    end.

%%%===================================================================
%%% Datastore callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Returns model's context.
%% @end
%%--------------------------------------------------------------------
-spec get_ctx() -> datastore:ctx().
get_ctx() ->
    ?CTX.


%%--------------------------------------------------------------------
%% @doc
%% Returns model's record version.
%% @end
%%--------------------------------------------------------------------
-spec get_record_version() -> datastore_model:record_version().
get_record_version() ->
    1.


%%--------------------------------------------------------------------
%% @doc
%% Returns model's record structure in provided version.
%% @end
%%--------------------------------------------------------------------
-spec get_record_struct(datastore_model:record_version()) -> datastore_model:record_struct().
get_record_struct(1) ->
    {record, [
        {pod_statuses, #{string => {integer, string}}},
        {pod_event_logs, #{string => string}}
    ]}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%% @private
-spec gen_registry_id(function_name()) -> id().
gen_registry_id(FunctionName) ->
    datastore_key:new_from_digest([FunctionName]).

%% @private
-spec gen_pod_event_log_id(id(), pod_id()) -> infinite_log:log_id().
gen_pod_event_log_id(RegistryId, PodId) ->
    datastore_key:adjacent_from_digest([PodId], RegistryId).


%% @private
-spec ensure_pod_event_log(id(), pod_id(), infinite_log:log_id()) -> ok.
ensure_pod_event_log(RegistryId, PodId, LogId) ->
    case json_based_infinite_log_backend:create(LogId, #{}) of
        ok ->
            ok = ?extract_ok(datastore_model:update(?CTX, RegistryId, fun(Registry) ->
                {ok, Registry#atm_openfaas_function_activity_registry{
                    pod_event_logs = maps:put(
                        PodId, LogId, Registry#atm_openfaas_function_activity_registry.pod_event_logs
                    )
                }}
            end));
        {error, already_exists} ->
            ok
    end.


%% @private
-spec consume_pod_status_report(atm_openfaas_function_pod_status_report:record()) -> ok.
consume_pod_status_report(#atm_openfaas_function_pod_status_report{
    timestamp = Timestamp,
    function_name = FunctionName,
    pod_id = PodId,
    current_pod_status = CurrentPodStatus,
    pod_event = PodEvent
}) ->
    RegistryId = gen_registry_id(FunctionName),
    LogId = gen_pod_event_log_id(RegistryId, PodId),
    LogValue = pack_pod_event(Timestamp, PodEvent),
    case json_based_infinite_log_backend:append(LogId, LogValue) of
        ok ->
            ok;
        {error, not_found} ->
            ensure_pod_event_log(RegistryId, PodId, LogId),
            ok = json_based_infinite_log_backend:append(LogId, LogValue)
    end,

    ok = ?extract_ok(datastore_model:update(?CTX, RegistryId, fun(Registry) ->
        PreviousPodStatuses = Registry#atm_openfaas_function_activity_registry.pod_statuses,
        {ok, Registry#atm_openfaas_function_activity_registry{
            pod_statuses = case maps:find(PodId, PreviousPodStatuses) of
                {ok, {ObservedAt, _}} when ObservedAt >= Timestamp ->
                    PreviousPodStatuses;
                _ ->
                    maps:put(PodId, {Timestamp, CurrentPodStatus}, PreviousPodStatuses)
            end
        }}
    end)).


%% @private
-spec pack_pod_event(infinite_log:timestamp(), pod_event()) -> json_utils:json_map().
pack_pod_event(Timestamp, PodEvent) ->
    #{
        <<"timestamp">> => Timestamp,
        <<"payload">> => PodEvent
    }.


%% @private
-spec unpack_pod_event(json_utils:json_map()) -> {infinite_log:timestamp(), pod_event()}.
unpack_pod_event(#{
    <<"timestamp">> := Timestamp,
    <<"payload">> := PodEvent
}) ->
    {Timestamp, PodEvent}.