#!/bin/bash

# Display usage help
error_bad_args()
{
	echo "Usage:" 
	echo "variant 1: (argument order can be arbitrary)"
	echo "	$0 -workers worker1@host worker2@host ... -main_ccm main_ccm_node@host [-opt_ccms opt_ccm_node1@host opt_ccm_node2@host ...] -db_nodes dbnode1@host dbnode2@host ..."
	echo " "
	echo "variant 2: (file 'gen_test.args' with arguments present in script directory)"
	echo "	$0"
	echo " "
	echo "Additional parameters: (acceptable in both variants)"
	echo "-start -> start test environment immediately after generation"
	echo "-start_no_generate -> start test environment according to arguments, skipping the generation (only after generating one)"
	exit 1	
}

# Function used to retrieve a parameter from script arguments. 
# args: 
# $1: <<script arguments>>   (arguments passed to the script; $*)
# $2: <<token of desired parameter>>    (eg. '-main_ccm' to retrieve main ccm name)
# $3: <<single|list>>      (expecting result as a single term or a list?)
# 
# The function starts reading parameters after ocurrence of desired token and continues for one word (single) or until it stumbles upon
# another token starting with '-' or end of line (list)
get_parameter_from_args()
{
	local ARGS=$1
	local TOKEN=$2
	local RETURN_OPTION=$3

	# Find the occurence of desired token. If there isn't one, there was no parameter value specified = error. 
	# Exception: -opt_ccms and -storage_config_path could have been left empty intentionally.
	local INDEX=`awk -v a=" $ARGS " -v b=" $TOKEN " 'BEGIN{print index(a, b)}'`
	if [[ $INDEX -eq 0 ]]; then
		if [ $TOKEN == '-opt_ccms' ] || [ $TOKEN == '-storage_config_path' ]; then
			RESULT=""
			return
		else
			echo " "
			echo "Error: missing parameter"
			echo "'$TOKEN' must occur in script arguments."
			echo "Terminating."
			echo " "
			error_bad_args
			exit 1
		fi
	fi

	# Trim the arguments string so that it starts after the token
	local ARGS=${ARGS:$(($INDEX + ${#TOKEN})):${#ARGS}}

	# Find the next occurence of a hyphen 
	INDEX=`awk -v a="$ARGS" -v b="-" 'BEGIN{print index(a, b)}'`

	# If its zero, the ARGS variable holds the desired string. If not, cut off the part after the hyphen
	if [[ $INDEX -gt 0 ]]; then
		ARGS=${ARGS:0:$(($INDEX - 1))}
	fi

	# If the expected result is a single word, get the first one from remaining string. 
	# This somehow resolves errors like passing a double word 'name' parameter.
	if [[ $RETURN_OPTION == "single" ]]; then
		ARGS=`echo $ARGS | cut -f1 -d' '`
	else
		ARGS=`echo $ARGS`          # trims spaces from the beginning of the list
	fi

	# If the result is empty, there was no parameter value specified = error. Exception: -opt_ccms could have been left empty intentionally.
	if [[ $ARGS == "" ]]; then
		if [[ $TOKEN == '-opt_ccms' ]]; then
			RESULT=""
			return
		else
			echo " "
			echo "Error: missing parameter"
			echo "'$TOKEN' must occur in script arguments or 'gen_test.args' file."
			echo "Terminating."
			echo " "
			error_bad_args
			exit 1
		fi
	fi

	# "return" the parameter(s)
	RESULT=$ARGS
}


# Enter the script directory
PATH_TO_SCRIPT=`echo $0 | sed "s/gen_test$//g"`
cd $PATH_TO_SCRIPT

# Accepting only no args, -start or -start_no_generate and reading from file. Otherwise all args have to be passed via args
if [[ $# -eq 0 ]] || 
	[[ $# -eq 1  && $1 == "-start" ]] || 
	[[ $# -eq 1  && $1 == "-start_no_generate" ]]; then
	# Check for .args file
	if [[ -f gen_dev.args ]]; then
		# And execute the script with the args from there
		ARGS=`cat gen_test.args`
		if [[ $1 == "" ]]; then
			echo "Using arguments from gen_test.args"
		else
			echo "Using arguments from gen_test.args with $1 option"			
		fi
		./gen_test $ARGS $1
		exit 0
	else
		# Error; no args file
		error_bad_args
	fi
fi


#####################################
# GATHER ARGS

# Get worker list from script args
get_parameter_from_args "$*" -workers list
WORKERS=$RESULT

# Get main_ccm name from script args
get_parameter_from_args "$*" -main_ccm single
MAIN_CCM=$RESULT

# Get opt_ccms from script args
get_parameter_from_args "$*" -opt_ccms list
OPT_CCMS=$RESULT

# Get db_nodes from script args
get_parameter_from_args "$*" -db_nodes list
DB_NODES=$RESULT

# Check for storage_config_path name in script args
get_parameter_from_args "$*" -storage_config_path single
STORAGE_CONFIG_PATH=$RESULT

# Initially, don't start the environment
DO_START=0

# Check if -start_no_generate option appeared
INDEX=`awk -v a=" $* " -v b=" -start_no_generate " 'BEGIN{print index(a, b)}'`
if [[ $INDEX -eq 0 ]]; then
	# It didn't, generation is needed

	echo " "
	echo "==================================================================="
	echo "Generating test environment"
	echo " "

	# Compile the code and generate the release (it's needed only once, then the package will be copied proper amount of times)
	make compile
	if [ $? -ne 0 ]; then
        echo ""
        echo "Error during code compilation."
        echo "Terminating."
        exit 1
    fi
	./rebar generate
	if [ $? -ne 0 ]; then
        echo ""
        echo "Error during release generation."
        echo "Terminating."
        exit 1
    fi
	chmod u+x ./releases/oneprovider_node/bin/oneprovider_node
	chmod u+x ./releases/oneprovider_node/bin/oneprovider

	# Generate releases for all nodes
	ALL_NODES="$WORKERS $MAIN_CCM $OPT_CCMS"
	for NODE in $ALL_NODES
	do
		./gen_dev -name $NODE -main_ccm $MAIN_CCM -opt_ccms $OPT_CCMS -db_nodes $DB_NODES -storage_config_path $STORAGE_CONFIG_PATH -no_generate
	done

	echo " "
	echo "Test environment generated succesfully."
else
	# It did, do the starting
	DO_START=1
fi

# Check if -start option appeared
INDEX=`awk -v a=" $* " -v b=" -start " 'BEGIN{print index(a, b)}'`
if [[ $INDEX -gt 0 ]]; then
	# It did, do the starting
	DO_START=1
fi

if [[ $DO_START -eq 1 ]]; then
	# Start the environment
	echo " "
	echo "==================================================================="
	echo "Starting test environment"
	echo " "


	# Start all nodes
	ALL_NODES="$MAIN_CCM $OPT_CCMS $WORKERS"
	for NODE in $ALL_NODES
	do
		# Get short name
		AT_INDEX=`expr index "$NODE" @`
		if [[ $AT_INDEX -gt 0 ]]; then
			NODE_NAME_WITHOUT_HOSTNAME=${NODE:0:(($AT_INDEX - 1))}
		else
			# If there is no '@', do nothing
			NODE_NAME_WITHOUT_HOSTNAME=$NODE
		fi

		echo "Starting node: $NODE_NAME_WITHOUT_HOSTNAME..."
		./releases/test_cluster/$NODE_NAME_WITHOUT_HOSTNAME/bin/oneprovider_node start
        if [ $? -ne 0 ]; then
            echo ""
            echo "Error during start of node $NODE_NAME_WITHOUT_HOSTNAME. Is the test environment ready?"
            exit 1
        fi
	done

	echo " "
	echo "Test environment started succesfully."	
fi

exit 0