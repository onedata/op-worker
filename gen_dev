#!/bin/bash

# Setup sed interactive options
if [ "`uname -s`" = "Darwin" ]; then
    SED_OPTS="-i '' -e"
else
    SED_OPTS="-i"
fi

# Display usage help
error_bad_args()
{
	echo "Usage:"
	echo "variant 1: (argument order can be arbitrary)"
	echo "	$0 -name node_name@host -main_ccm main_ccm_node@host [-opt_ccms opt_ccm_node1@host opt_ccm_node2@host ...] -db_nodes dbnode1@host dbnode2@host ... [-storage_config_path \"/path\"] [-output_dir \"/path\"]"
	echo " "
	echo "variant 2: (file 'gen_dev.args' with arguments present in script directory or file pointed by GEN_DEV_ARGS_FILE env variable"
	echo "	$0"
	echo " "
	echo "Additional parameters: (acceptable in both variants)"
	echo "-no_compile -> skip code compilation straight to release generation."
	echo "-no_generate -> skip code compilation and release generation (creates a copy of existing release)."	
	exit 1	
}

# Function used to retrieve a parameter from script arguments. 
# args: 
# $1: <<script arguments>>   (arguments passed to the script; $*)
# $2: <<token of desired parameter>>    (eg. '-main_ccm' to retrieve main ccm name)
# $3: <<single|list>>      (expecting result as a single term or a list?)
# 
# The function starts reading parameters after ocurrence of desired token and continues for one word (single) or until it stumbles upon
# another token starting with '-' or end of line (list)
get_parameter_from_args()
{
	local ARGS=$1
	local TOKEN=$2
	local RETURN_OPTION=$3

	# Find the occurence of desired token. If there isn't one, there was no parameter value specified = error. 
	# Exception: -opt_ccms and -storage_config_path could have been left empty intentionally.
	local INDEX=`awk -v a=" $ARGS " -v b=" $TOKEN " 'BEGIN{print index(a, b)}'`
	if [[ $INDEX -eq 0 ]]; then
		if [ $TOKEN == '-opt_ccms' ] || [ $TOKEN == '-storage_config_path' ] || [ $TOKEN == '-output_dir' ]; then
			RESULT=""
			return
		else
			echo " "
			echo "Error: missing parameter"
			echo "'$TOKEN' must occur in script arguments."
			echo "Terminating."
			echo " "
			error_bad_args
			exit 1
		fi
	fi

	# Trim the arguments string so that it starts after the token
	local ARGS=${ARGS:$(($INDEX + ${#TOKEN})):${#ARGS}}

    # Find the next occurence of a hyphen that is just after a space
	INDEX=`awk -v a=" $ARGS" -v b=" -" 'BEGIN{print index(a, b)}'`

	# If its zero, the ARGS variable holds the desired string. If not, cut off the part after the hyphen
	if [[ $INDEX -gt 0 ]]; then
		ARGS=${ARGS:0:$(($INDEX - 1))}
	fi

	# If the expected result is a single word, get the first one from remaining string.
	# This somehow resolves errors like passing a double word 'name' parameter.
	if [[ $RETURN_OPTION == "single" ]]; then
		ARGS=`echo $ARGS | cut -f1 -d' '`
	else
		ARGS=`echo $ARGS`          # trims spaces from the beginning of the list
	fi

	# If the result is empty, there was no parameter value specified = error. Exception: -opt_ccms could have been left empty intentionally.
	if [[ $ARGS == "" ]]; then
		if [[ $TOKEN == '-opt_ccms' ]]; then
			RESULT=""
			return
		else
			echo " "
			echo "Error: missing parameter"
			echo "'$TOKEN' must occur in script arguments."
			echo "Terminating."
			echo " "
			error_bad_args
			exit 1
		fi
	fi

	# "return" the parameter(s)
	RESULT=$ARGS
}

# Enter the script directory
PATH_TO_SCRIPT=`echo $0 | sed "s/gen_dev$//g"`
cd $PATH_TO_SCRIPT

# Accepting only no args, -no_compile or -no_generate and reading from file. Otherwise all args have to be passed via args
if  [[ $# -eq 0 ]] || 
	[[ $# -eq 1  && $1 == "-no_compile" ]] || 
	[[ $# -eq 1  && $1 == "-no_generate" ]]; then

	ARGS_FILE="${GEN_DEV_ARGS_FILE}"
	if [ -z "${ARGS_FILE}" ]; then
	    ARGS_FILE=gen_dev.args
	fi

	# Check for .args file
	if [[ -f "${ARGS_FILE}" ]]; then
		# Get args from 
		ARGS=`cat "${ARGS_FILE}"`
		# And execute the script with the args from there
		if [[ $1 == "" ]]; then
			echo "Using arguments from gen_dev.args"
		else
			echo "Using arguments from gen_dev.args with $1 option"			
		fi
		./gen_dev $ARGS $1
		exit 0
	else
		# Error; no args file
		error_bad_args
	fi
fi


#####################################
# GATHER ARGS

# Get node name from script args
get_parameter_from_args "$*" -name single
NODE_NAME=$RESULT

# Get main_ccm name from script args
get_parameter_from_args "$*" -main_ccm single
MAIN_CCM=$RESULT

# Get opt_ccms from script args
get_parameter_from_args "$*" -opt_ccms list
OPT_CCMS=$RESULT

# Get db_nodes from script args
get_parameter_from_args "$*" -db_nodes list
DB_NODES=$RESULT

# Check for storage_config_path name in script args
get_parameter_from_args "$*" -storage_config_path single
STORAGE_CONFIG_PATH=$RESULT

get_parameter_from_args "$*" -output_dir single
TEST_NODE_DIR=$RESULT

if [ -z "$TEST_NODE_DIR" ]; then
    TEST_NODE_DIR=test_cluster
fi

# Get short node name (without hostname) and hostname
AT_INDEX=`echo "$NODE_NAME" | sed -n "s/["@"].*//p" | wc -c`
if [[ $AT_INDEX -gt 0 ]]; then
	NODE_NAME_WITHOUT_HOSTNAME=${NODE_NAME:0:(($AT_INDEX - 1))}
	HOSTNAME=${NODE_NAME:(($AT_INDEX - 1)):${#NODE_NAME}}
else
    echo " "
    echo "Error: longname expected"
    echo "'$NODE_NAME' must be a valid erlang longname."
    echo "Terminating."
    echo " "
    exit 1
fi

echo " "
echo "========================================"
echo "Generating release for $NODE_NAME in    /releases/${TEST_NODE_DIR}/$NODE_NAME_WITHOUT_HOSTNAME"

# Skip generation if -no_generate is in args
INDEX=`awk -v a=" $* " -v b=" -no_generate " 'BEGIN{print index(a, b)}'`
if [[ $INDEX -eq 0 ]]; then

	# Skip compilation if -no_compile is in args
	INDEX=`awk -v a=" $* " -v b=" -no_compile " 'BEGIN{print index(a, b)}'`
	if [[ $INDEX -eq 0 ]]; then
		# Compile the code
		make deps
		make compile
		if [ $? -ne 0 ]; then
	        echo ""
	        echo "Error during code compilation."
	        echo "Terminating."
	        exit 1
	    fi
	fi

	# Generate the release
	./rebar generate
	if [ $? -ne 0 ]; then
        echo ""
        echo "Error during release generation."
        echo "Terminating."
        exit 1
    fi
	chmod u+x ./releases/oneprovider_node/bin/oneprovider_node
	chmod u+x ./releases/oneprovider_node/bin/oneprovider
else
	# User requested to skip release generation
	if [[ ! -d releases/oneprovider_node ]]; then
		echo "Error: no release found"
		echo "Cannot skip release generation - no release package found."
		echo "Try executing the script without -no_generate option."
		echo "Terminating."
		exit 1
	fi
fi

# Create directory for test nodes if it doesn't exit
mkdir -p "releases/${TEST_NODE_DIR}"


# Originally let's assume this node is a worker
NODE_TYPE="worker"
# Check if the node name equals main CCM -> this node is a CCM
if [[ $NODE_NAME == $MAIN_CCM ]]; then
	NODE_TYPE="ccm"
fi
for OPT_CCM in $OPT_CCMS
do
	# Check if the node name equals current CCM -> this node is a CCM
	if [[ $NODE_NAME == $OPT_CCM ]]; then
		NODE_TYPE="ccm"
	fi
done


# Remove old release
rm -r "releases/${TEST_NODE_DIR}/$NODE_NAME_WITHOUT_HOSTNAME" 2>/dev/null

# Get application version
START_ERL=`cat "releases/oneprovider_node/releases/start_erl.data"`
APP_VSN=${START_ERL#* }

# Replace developer_mode env to enable developer functionalities in generated package
sed -i "s/-oneprovider_node developer_mode.*/-oneprovider_node developer_mode true/g" releases/oneprovider_node/releases/$APP_VSN/vm.args

# Copy the release package to proper location (directory named as the node without hostname), preserve mode
cp -R -p releases/oneprovider_node "releases/${TEST_NODE_DIR}/$NODE_NAME_WITHOUT_HOSTNAME"

# Execute the oneprovider script with proper arguments
./releases/${TEST_NODE_DIR}/$NODE_NAME_WITHOUT_HOSTNAME/bin/oneprovider \
-name $NODE_NAME -main_ccm $MAIN_CCM -opt_ccms $OPT_CCMS -db_nodes $DB_NODES -storage_config_path $STORAGE_CONFIG_PATH

# Get hostname to use it as the cookie
COOKIE=`hostname -f`

# Override cookie using db_node hostname if it's specified
FIRST_DB_NODE=${DB_NODES[0]}
AT_INDEX=`echo "$FIRST_DB_NODE" | sed -n "s/["@"].*//p" | wc -c`

if [[ $AT_INDEX -gt 0 ]]; then
	COOKIE=${FIRST_DB_NODE:$AT_INDEX:${#FIRST_DB_NODE}}
fi

# Replace the cookie
sed $SED_OPTS  "s/-setcookie.*/-setcookie '$COOKIE'/g" "releases/${TEST_NODE_DIR}/$NODE_NAME_WITHOUT_HOSTNAME/releases/$APP_VSN/vm.args"
echo "Cookie set to: $COOKIE"

# Generate a corresponding worker if this node is a CCM
if [[ $NODE_TYPE == "ccm" ]]; then
    echo " "
    echo "****************"
    echo "Generating worker for $NODE_NAME in    /releases/${TEST_NODE_DIR}/${NODE_NAME_WITHOUT_HOSTNAME}_worker"

    rm -r "releases/${TEST_NODE_DIR}/${NODE_NAME_WITHOUT_HOSTNAME}_worker" 2>/dev/null

    cp -R -p releases/oneprovider_node "releases/$TEST_NODE_DIR/${NODE_NAME_WITHOUT_HOSTNAME}_worker"

    ./releases/${TEST_NODE_DIR}/${NODE_NAME_WITHOUT_HOSTNAME}_worker/bin/oneprovider \
    -name ${NODE_NAME_WITHOUT_HOSTNAME}_worker${HOSTNAME} -main_ccm $MAIN_CCM -opt_ccms $OPT_CCMS -db_nodes $DB_NODES -storage_config_path $STORAGE_CONFIG_PATH

    sed $SED_OPTS  "s/-setcookie.*/-setcookie '$COOKIE'/g" "releases/${TEST_NODE_DIR}/${NODE_NAME_WITHOUT_HOSTNAME}_worker/releases/$APP_VSN/vm.args"
    echo "Cookie set to: $COOKIE"
fi

exit 0
