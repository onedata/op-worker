#!/bin/bash

# Setup sed interactive options
if [ "`uname -s`" = "Darwin" ]; then
    SED_OPTS="-i '' -e"
else
    SED_OPTS="-i"
fi

display_help()
{
	echo "
Prerequisites
-------------

Firstly, the user must have execution rights on both '/bin/oneprovider' and '/bin/oneprovider_node' scripts.

Secondly, 'config.args' file must be present in 'bin' directory (along with 'oneprovider' script).

Setting parameters
------------------

List of parameters that can be set:

    name                -> name of the node (erlang long name)
    main_ccm            -> main CCM name (of the cluster this node operates in)
    opt_ccms            -> list of optional CCMs (this parameter is not mandatory)
    db_nodes            -> list of DBMS nodes
    storage_config_path -> path to file containing information about storage

Primarily, these parameters are retrieved from 'config.args' file. It should contain these parameters in following manner:

    <parameter_name>: <parameter_value>

Another way is passing these parameters via command line arguments. In this case the syntax is:

    ./oneprovider -<parameter1_name> <parameter1_value> -<parameter2_name> <parameter2_value> ...

NOTE:

* parameters passed via command line OVERRIDE those in 'config.args' file
* \"command line way\" can specify any subset of parameters, for instance:
    * './oneprovider' will cause the script to use all parameters from 'config.args'
    * './oneprovider -name somename@host.net' will cause the script to use parameters from 'config.args' except node name
    * './oneprovider -opt_ccms' (no opt_ccms value specified) will override opt_ccms from 'config.args' with null value
* (both) parameter order can be arbitrary
* (both) multiple values (eg. DBMS nodes) are passed as a space-delimited list (eg. -db_nodes dbnode1@host.net dbnode2@host.net)
* (both) parameter values can't contain spaces or hyphens
* (command line) parameter names are preceded by a hyphen; '-'

Starting a release
------------------

There are three options which are used to start a release. They are passed along with other arguments to the 'oneprovider' script.

    -start    -> the script will perform the configuration and then start the node as a daemon
    -attach   -> the script will skip configuration and try to attach to a running node with an erlang shell (used after -start)
    -console  -> the script will perform the configuration and then start the node with an erlang shell

If none of these arguments occur, the script will terminate after setting up the configuration.

Full example of usage
---------------------

    ~$  ./oneprovider -name mynode@host.net -main_ccm ccmnode@host.net -console

Above command will configure the release according to 'config.args', except for name and main_ccm which will be modified
corresponding to command line arguments. Then, the node will be started presenting to the user with an erlang shell."

	exit 0
}

# Function used to retrieve a parameter from script arguments. 
# args: 
# $1: <<script arguments>>   (arguments passed to the script; $*)
# $2: <<token of desired parameter>>    (eg. '-main_ccm' to retrieve main ccm name)
# $3: <<single|list>>      (expecting result as a single term or a list?)
# 
# The function starts reading parameters after ocurrence of desired token and continues for one word (single) or until it stumbles upon
# another token starting with '-' or end of line (list)
get_parameter_from_args()
{
	local ARGS=$1
	local TOKEN=$2
	local RETURN_OPTION=$3

	# Find the occurence of desired token. If there isn't one, return with -no_param value.
	local INDEX=`awk -v a=" $ARGS " -v b=" $TOKEN " 'BEGIN{print index(a, b)}'`
	if [[ $INDEX -eq 0 ]]; then
		RESULT="-no_param"
		return
	fi

	# Trim the arguments string so that it starts after the token
	local ARGS=${ARGS:$(($INDEX + ${#TOKEN})):${#ARGS}}

	# Find the next occurence of a hyphen 
	INDEX=`awk -v a=" $ARGS" -v b=" -" 'BEGIN{print index(a, b)}'`

	# If its zero, the ARGS variable holds the desired string. If not, cut off the part after the hyphen
	if [[ $INDEX -gt 0 ]]; then
        ARGS=${ARGS:0:$(($INDEX - 1))}
	fi

	# If the expected result is a single word, get the first one from remaining string. 
	# This somehow resolves errors like passing a double word 'name' parameter.
	if [[ $RETURN_OPTION == "single" ]]; then
		ARGS=`echo $ARGS | cut -f1 -d' '`
	else
		ARGS=`echo $ARGS`          # trims spaces from the beginning of the list
	fi

	# If the result is empty, there was no parameter value specified. Exception: -opt_ccms could have been left empty intentionally.
	if [[ $ARGS == "" ]] && [[ $TOKEN != '-opt_ccms' ]]; then
		RESULT="-no_param"
		return
	fi

	# "return" the parameter(s)
	RESULT=$ARGS
}

# Function used to retrieve a parameter from 'config.args' file. 
# args:
# $1: <<token of desired parameter>> (eg. main_ccm: to retrieve main ccm name)
# $2: <<single|list>>      (expecting result as a single term or a list?)
get_parameter_from_file()
{
	local TOKEN=$1
	local RETURN_OPTION=$2

	RESULT=`grep "$TOKEN" config.args`
	RESULT=${RESULT:${#TOKEN}:${#RESULT}}
	
	# If the expected result is a single word, get the first one from remaining string. 
	# This somehow resolves errors like passing a double word 'name' parameter.
	if [[ $RETURN_OPTION == "single" ]]; then
		RESULT=`echo $RESULT | cut -f1 -d' '`
	else
		RESULT=`echo $RESULT`          # trims spaces from the beginning of the list
	fi

	# If parameter doesn't occur in config file, the script shall not proceed (it couldn't have been in args either)
	# 'opt_ccms' is an exception; it's not mandatory
	if [[ $RESULT == "" ]] && [[ $TOKEN != 'opt_ccms:' ]]; then
		echo " "
		echo "Error: missing parameter"
		echo "'${TOKEN%?}' must occur in script arguments or 'config.args' file."
		echo "Terminating."
		echo " "
		echo "for usage help, type:"
		echo "	~$ ./oneprovider -help "
		exit 1
	fi
}

# Check for -help otpion
INDEX=`awk -v a=" $* " -v b=" -help " 'BEGIN{print index(a, b)}'`
if [[ $INDEX -gt 0 ]]; then
	display_help
fi

# Enter the script directory
PATH_TO_SCRIPT=`echo $0 | sed "s/oneprovider$//g"`
cd $PATH_TO_SCRIPT

# Ensure config file exists
if [ ! -f config.args ]; then
	echo " "
	echo "Error: missing configuration file"
	echo "'config.args' not found in script directory."
	echo "Terminating."
	echo " "
	echo "for usage help, type:"
	echo "	~$ ./oneprovider -help "
	exit 1
fi

# Check for '-attach' option. If it occurs, it's logical to assume the node is already running, so no further configuration is needed
INDEX=`awk -v a=" $* " -v b=" -attach " 'BEGIN{print index(a, b)}'`
if [[ $INDEX -gt 0 ]]; then

	# User requested attaching to the node
	echo " "
	echo "==========================================================="
	echo "Attaching to the running node..."
	echo " "

	../bin/oneprovider_node attach

	# The attachment failed
    if [ $? -ne 0 ]; then
        echo ""
        echo "Error during attaching to the node."
        echo "Is the node running?"
        exit 1
    fi

   	exit 0
fi


#####################################
# GATHER CONFIG FROM ARGS AND CONFIG FILE

#####################################
# NODE NAME

# Check for node name in script args
get_parameter_from_args "$*" -name single
NODE_NAME=$RESULT

# If there was none specified...
if [[ $NODE_NAME == "-no_param" ]]; then
	# ... retrieve node name from config file
	get_parameter_from_file name: single
	NODE_NAME=$RESULT
fi

#####################################
# MAIN CCM

# Check for main_ccm name in script args
get_parameter_from_args "$*" -main_ccm single
MAIN_CCM=$RESULT

# If there was none specified...
if [[ $MAIN_CCM == "-no_param" ]]; then
	# ... retrieve main_ccm name from config file
	get_parameter_from_file main_ccm: single
	MAIN_CCM=$RESULT
fi

# Originally let's assume this node is a worker 
NODE_TYPE="worker"
# Check if the node name equals main CCM -> this node is a CCM
if [[ $NODE_NAME == $MAIN_CCM ]]; then
	NODE_TYPE="ccm"
fi

#####################################
# OPTIONAL CCMS

# Check for opt_ccms in script args
get_parameter_from_args "$*" -opt_ccms list
OPT_CCMS=$RESULT

# If there were none specified...
if [[ $OPT_CCMS == "-no_param" ]]; then
	# ... retrieve opt_ccms from config file
	get_parameter_from_file opt_ccms: list
	OPT_CCMS=$RESULT
fi

# And turn them into a formatted list, along with main ccm
CCMS_LIST="['$MAIN_CCM',"
for OPT_CCM in $OPT_CCMS
do
    CCMS_LIST="$CCMS_LIST'$OPT_CCM',"

	# Check if the node name equals current CCM -> this node is a CCM
	if [[ $NODE_NAME == $OPT_CCM ]]; then
		NODE_TYPE="ccm"
	fi
done
CCMS_LIST="${CCMS_LIST%?}]"



#####################################
# DBMS NODES

# Check for db_nodes in script args
get_parameter_from_args "$*" -db_nodes list
DB_NODES=$RESULT

# If there were none specified...
if [[ $DB_NODES == "-no_param" ]]; then
	# ... retrieve db_nodes from config file
	get_parameter_from_file db_nodes: list
	DB_NODES=$RESULT
fi

# And turn them into a formatted list
DB_NODES_LIST="["
for DB_NODE in $DB_NODES
do
    DB_NODES_LIST="$DB_NODES_LIST'$DB_NODE',"
done
DB_NODES_LIST="${DB_NODES_LIST%?}]"

#####################################
# STORAGE CONFIG PATH

# Check for storage_config_path name in script args
get_parameter_from_args "$*" -storage_config_path single
STORAGE_CONFIG_PATH=$RESULT

# If there was none specified...
if [[ $STORAGE_CONFIG_PATH == "-no_param" ]]; then
	# ... retrieve storage_config_path from config file
	get_parameter_from_file storage_config_path: single
	STORAGE_CONFIG_PATH=$RESULT
fi

#####################################
# PUT CONFIGURATION INTO 'VM.ARGS' AND 'SYS.CONFIG'

echo " "
echo "-------"
echo "Applying configuration:"
echo " "
echo "NODE_NAME           = $NODE_NAME"
echo "NODE_TYPE           = $NODE_TYPE"
echo "MAIN_CCM            = $MAIN_CCM"
echo "OPT_CCMS            = $OPT_CCMS"
echo "DB_NODES            = $DB_NODES"
echo "STORAGE_CONFIG_PATH = $STORAGE_CONFIG_PATH"

# Get application version
START_ERL=`cat ../releases/start_erl.data`
APP_VSN=${START_ERL#* }

# Replace node name
sed $SED_OPTS "s/-name.*/-name $NODE_NAME/g" ../releases/$APP_VSN/vm.args

# Replace node type
sed $SED_OPTS "s/{node_type,.*/{node_type, $NODE_TYPE},/g" ../releases/$APP_VSN/sys.config

# Replace ccm nodes
sed $SED_OPTS "s/{ccm_nodes,.*/{ccm_nodes, $CCMS_LIST},/g" ../releases/$APP_VSN/sys.config

# Replace DBMS nodes
sed $SED_OPTS "s/{db_nodes,.*/{db_nodes, $DB_NODES_LIST},/g" ../releases/$APP_VSN/sys.config

# Replace STORAGE_CONFIG_PATH
sed $SED_OPTS "s@{storage_config_path,.*@{storage_config_path, $STORAGE_CONFIG_PATH},@g" ../releases/$APP_VSN/sys.config

# Remove config for distributed application from sys.config
sed -n $SED_OPTS '1h;1!H;${;g;s/\[.*%% SASL/ %% SASL/g;p;}' ../releases/$APP_VSN/sys.config

# If this node is a ccm and there is at least two of CCM nodes in the cluster, create a proper DA entry
if [[ $NODE_TYPE == 'ccm' ]] && [[ $OPT_CCM != "" ]]; then

	# Produce list of ccms: [main_ccm, {opt_ccm1, opt_ccm2...}]
	CCM_HIERARCHY_LIST="['$MAIN_CCM', {"
	for OPT_CCM in $OPT_CCMS
	do
	    CCM_HIERARCHY_LIST="$CCM_HIERARCHY_LIST'$OPT_CCM',"
	done
	CCM_HIERARCHY_LIST="${CCM_HIERARCHY_LIST%?}}]"

	# Produce list of mandatory sync ccms (skip self)
	CCM_SYNC_LIST="["
	if [ $NODE_NAME != $MAIN_CCM ]; then
		CCM_SYNC_LIST="['$MAIN_CCM', "
	fi
	for OPT_CCM in $OPT_CCMS
	do
		if [ $NODE_NAME != $OPT_CCM ]; then
	    	CCM_SYNC_LIST="$CCM_SYNC_LIST'$OPT_CCM', "
	    fi
	done
	CCM_SYNC_LIST="${CCM_SYNC_LIST:0:((${#CCM_SYNC_LIST} - 2))}]"

	# Produce a proper config entry
	DIST_APP_CFG="[
 %% kernel config for ccm distributed application
 {kernel,
  [{distributed, [{oneprovider_node, 5000, $CCM_HIERARCHY_LIST}]},
   {sync_nodes_mandatory, $CCM_SYNC_LIST},
   {sync_nodes_timeout, 60000}
  ]
 },
 "

# If this node is a worker or an only CCM, add only '[' that has been removed by sed
else
	DIST_APP_CFG="["
fi

# Merge all into one string
SYS_CFG=`cat ../releases/$APP_VSN/sys.config`
SYS_CFG="$DIST_APP_CFG$SYS_CFG"

# And overwrite the old sys.config
echo "$SYS_CFG" > ../releases/$APP_VSN/sys.config

# Applying config is done
echo " "
echo "Done."

# Check for '-console' option (-console overrides -start)
INDEX=`awk -v a=" $* " -v b=" -console " 'BEGIN{print index(a, b)}'`
if [[ $INDEX -gt 0 ]]; then

	# User requested starting the node with console
	echo " "
	echo "==========================================================="
	echo "Starting $NODE_NAME with erlang console..."
	echo " "
	../bin/oneprovider_node console

	# No need for result checking; user will get the dump in console

else
	# Check for '-start' option
	INDEX=`awk -v a=" $* " -v b=" -start " 'BEGIN{print index(a, b)}'`
	if [[ $INDEX -gt 0 ]]; then

		# User requested starting the node
		echo " "
		echo "==========================================================="
		echo "Starting $NODE_NAME..."
		echo " "
		../bin/oneprovider_node start
		../bin/oneprovider_node ping

		# The node failed to start or is not responding to pings
        if [ $? -ne 0 ]; then
            echo ""
            echo "Error during start of the node or it doesn't respond to pings."
            echo "Start the node with console or consult erl_crash.dump for details."
            exit 1
        fi
	fi
fi

exit 0
